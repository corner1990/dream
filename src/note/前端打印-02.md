
# 前端实现分页打印（二）
> 上一篇文章主要贴出了接触的页面结构代码，关于分页计算，分页统计的代码，放在这个篇幅处理
>
### 在 invoice目录中新建文件hooks.ts,
> hoos 中进行函数逻辑的书写，以及导出数据对象
### 产品列表分页

```ts
export interface CheckFormProductItem {
    discountAmount: number;
    discountPrice: number;
    freeGiftQuantity: number;
    img: string;
    name: string;
    paidAmount: number;
    price: number;
    quantity: number;
    requireService: number;
    retailPrice: number;
    returnAmount: number;
    returnQuantity: number;
    salesAmount: number;
    salesPrice: number;
    serviceFee: number;
    skuId: number;
    sn: string;
    specification: string;
    unit: string;
}

type PageProductList = CheckFormProductItem[];
// 产品分页
const pageList = ref<PageProductList[]>([]);

// 保存页面列表
const produdtPageNum = ref<number>(0);

// 创建一个产品分页计算的hooks
export const useCalcProductPages = () => {
    let maxLen = 14; // 每页最多可显示商品数量
    const firstMaxLen = 10; // 首页可显示数据行数
    const otherMathLen = 14; // 没有订单信息的页面可以展示的页面行数

    // 初始化
    const initPageList = (products: CheckFormProductItem[]): PageProductList[] => {
        const list: PageProductList[] = []; // 存储分页
        const firstPage = products.slice(0, firstMaxLen);
        const otherProducts = products.slice(firstMaxLen);
        const loopCunt = Math.ceil(otherProducts.length / otherMathLen);

        // 根据产品信息行数，讲每一页的数据进行格式化，并存储页面列表list
        for (let i = 0; i < loopCunt; i += 1) {
            list.push(otherProducts.slice(i * otherMathLen, (i + 1) * otherMathLen));
        }
        // 最后将首页的数据放到最头部
        list.unshift(firstPage);
        return list;
    };
    // 更新页数 统计打印总页数，以及当前页会用到
    const { updatePageSize } = usePaginationInfo();

    // 计算产品需要多少页可以
    const calcProductPages = (products: CheckFormProductItem[]) => {
        let list: PageProductList[] = [];
        if (!Array.isArray(products)) {
            return list;
        }
        // 首页11条数据
        if (products.length <= 11) {
            // 只有一页
            list.push(products);
        } else {
            // 多页处理
            list = initPageList(products);
        }
        pageList.value = list;
        produdtPageNum.value = list.length;
        updatePageSize('productPageSize', list.length);
        return list;
    };

    // 计算产品table 下边距
    const calcProductTableMarginBottom = (prdocutLen: number, pageIndex: number): number => {
        let defaultMarginBottom: number = 40;

        const lineHeight = 44;
        if (pageIndex === 0) {
            // 首页特殊处理
            maxLen = 10;
        } else {
            maxLen = 14;
        }
        // 处理margin bottom
        if (prdocutLen < maxLen) {
            defaultMarginBottom += (maxLen - prdocutLen) * lineHeight;
        }
        defaultMarginBottom -= 1;
        return defaultMarginBottom;
    };

    return {
        pageList,
        produdtPageNum,
        calcProductPages,
        calcProductTableMarginBottom,
    };
};
```

### 收费明细分页计算
```ts

// 费用配置
export interface CostConfigItem {
    allowDiscount: number;
    code: string;
    id: number;
    lowestDiscount: number;
    name: string;
    required: number; // 是否必收
    type: number;
    typeName: string;
    value: number;
    version: number;
}
export interface OrderFeeDetailInfo {
    type: string;
    orderId: string;
    extendFeeList: CostConfigItem[];
    showFooter: boolean;
    currentPage?: number;
    marginBottom?: any;
    pageIndex: number;
    isLastFeeDetail: boolean;
}
// 资金明细分页数据
export const orderInvoiceFeePageList = ref<OrderFeeDetailInfo[][]>([]);
// 处理分页
const formatFeeListPagination = <T>(feeList: T): T => {
    const pageMaxLen = 21; // // 页面最大行数包含标题；
    const lineHeight = 32; // 行高
    const maxHeight = pageMaxLen * lineHeight; // 页面最大行数包含标题  => 行高
    let startIdx: number = 0;
    let stepIdx: number = 0;
    const list = ((feeList as unknown) as { value: OrderFeeDetailInfo[] }).value;

    // 更新index
    const updateIdx = (idx: number): void => {
        startIdx = idx;
        stepIdx = 0;
    };
    // 获取有多少行，判断是否能占满一页
    const getLine = (lineList: OrderFeeDetailInfo[]) => {
        const len = lineList.reduce((prev: number, next: OrderFeeDetailInfo): number => {
            prev += next.extendFeeList.length;
            return prev;
        }, 0);

        return len;
    };
    // 计算margin bottom
    const getFeeDetailMarginBottom = (
        lineLen: number,
        detailLen: number,
        info: OrderFeeDetailInfo
    ): number => {
        const initMarginBottom: number = 16; // 默认下边距为16

        // (len - 1) * initMarginBottom 两个订单明细之间会有16像素的级间距
        const currentHeight =
            (lineLen + detailLen) * lineHeight + (detailLen - 1) * initMarginBottom;

        const currentMarginBottom = maxHeight - currentHeight + 25;
        // 没有下边距 需要做分页
        info.marginBottom = {
            marginBottom: `${currentMarginBottom}px`,
        };

        return currentMarginBottom;
    };
    // 对上一组数据强制分页
    const forcePreDetail = (infos: any) => {
        const newInfos = infos.slice(0, -1);
        const len = getLine(newInfos);
        const newPageInfo = newInfos[newInfos.length - 1];
        newPageInfo.showFooter = true;
        getFeeDetailMarginBottom(len, newInfos.length, newPageInfo);
    };

    const multipleDetailFormat = (lineLen: number, infos: OrderFeeDetailInfo[]) => {
        // 满足最大行数 或者 已经遍历所有 就进行处理
        if (lineLen + infos.length >= pageMaxLen || list.length === startIdx + stepIdx) {
            infos[infos.length - 1].showFooter = true;
            // 维护坐标
            updateIdx(startIdx + stepIdx);

            const resutlt = getFeeDetailMarginBottom(
                lineLen,
                infos.length,
                infos[infos.length - 1]
            );
            // 处理上一个
            if (resutlt <= 20) {
                infos[infos.length - 1].showFooter = false;
                infos[infos.length - 1].marginBottom = {};
                // 维护坐标
                updateIdx(startIdx - 1);
                forcePreDetail(infos);
            } else {
                updateIdx(startIdx + stepIdx);
            }
        }
    };
    // 计算页面
    const calcFeeListPage = () => {
        stepIdx += 1;
        const infos = list.slice(startIdx, startIdx + stepIdx);
        const lineLen = getLine(infos);

        // 单条数据判断出数据
        if (list.length === 1) {
            // 页面最多展示15行
            infos[0].showFooter = true;
            getFeeDetailMarginBottom(lineLen, infos.length, infos[0]);
            // 维护坐标
            startIdx = list.length;
            stepIdx = 0;
        } else {
            // 多行的处理
            multipleDetailFormat(lineLen, infos);
        }

        // 递归 直至处理完所有数据
        if (startIdx + stepIdx < list.length) {
            calcFeeListPage();
        }
    };

    // 首次开始计算
    calcFeeListPage();

    let feePageList: any = [[]];
    let pageIndex = 0;
    // 处理页面分页 下标 在展示时会用到
    list.forEach((item) => {
        feePageList[feePageList.length - 1].push(item);
        // 处理页面下标 分页
        if (item.showFooter) {
            feePageList.push([]);
            item.pageIndex = pageIndex;
            pageIndex += 1;
        }
    });
    // 去除空数组
    feePageList = feePageList.filter((arr: any[]) => arr.length);
    orderInvoiceFeePageList.value = feePageList;
    // 更新页数 
    const { updatePageSize } = usePaginationInfo();

    updatePageSize('orderDetailPageSize', feePageList.length);
    return feeList;
};
// 结算单价格明细
export const orderInvoiceFeeList = ref<OrderFeeDetailInfo[]>([]);

// 处理价格明细
const formatFeeList = (info: CheckFormOrderInfo): void => {
    orderInvoiceFeeList.value = [
        {
            type: 'orginOrder',
            orderId: info.orderId,
            extendFeeList: info.extendFeeList,
            showFooter: false,
            marginBottom: {},
            pageIndex: 0,
            isLastFeeDetail: false,
        },
    ];
    // 处理子单
    if (Array.isArray(info.subOrders)) {
        info.subOrders.forEach((subInfo) => {
            orderInvoiceFeeList.value.push({
                type: 'childOrder',
                orderId: subInfo.orderId,
                extendFeeList: subInfo.extendFeeList || [],
                showFooter: false,
                marginBottom: {},
                pageIndex: 0,
                isLastFeeDetail: false,
            });
        });
    }
    formatFeeListPagination<{ value: OrderFeeDetailInfo[] }>(orderInvoiceFeeList);
};

```

### 分页相关代码
```ts

// 保存页面信息
export const paginationInfo = reactive({
    productPageSize: 0, // 产品分页总页数
    summationPageSize: 1, // 订单合计页面默认单独一页
    orderDetailPageSize: 0, // 订单明细总页数
    totalPageSize: 0, // 所有页面数量汇总
    updateCount: 0, // 主要是确保产品信息和收费信息都计算完毕
});

// 处理分页数据
export const usePaginationInfo = () => {
    type PageSizeKey = keyof typeof paginationInfo;
    let timer: any = null;

    // 更新页面总数
    const updateTotalSize = () => {
        const keys: PageSizeKey[] = ['productPageSize', 'summationPageSize', 'orderDetailPageSize'];
        let totalPageSize = 0;
        keys.forEach((key) => {
            totalPageSize += paginationInfo[key];
        });

        paginationInfo.totalPageSize = totalPageSize;
    };
    // 获取当前模块从第几页开始渲染
    const getPageSizeStartIndex = (pageKey: PageSizeKey) => {
        let startIndex = 0;
        const keys: PageSizeKey[] = ['productPageSize', 'summationPageSize', 'orderDetailPageSize'];
        const keyIndex = keys.indexOf(pageKey);

        keys.slice(0, keyIndex).forEach((key) => {
            startIndex += paginationInfo[key];
        });

        return startIndex;
    };
    /**
     * 更新某个单独的key
     * @param key 页面属性key
     * @param size 页数
     */
    const updatePageSize = (key: PageSizeKey, size: number) => {
        clearTimeout(timer);
        paginationInfo[key] = size;
        paginationInfo.updateCount += 1;

        timer = setTimeout(updateTotalSize, 100);
    };
    return {
        paginationInfo,
        updatePageSize,
        getPageSizeStartIndex,
    };
};
```

### 页面初始化
> vue3 在外部创造的变量更新后会一直保留状态，所以 页面数据更新 进入页面需要对当前页面数据清空，防止出现上次页面的信息
```ts

// 清除页面数据
const clearPageInfo = () => {
    pageList.value = [];
    orderInvoiceFeePageList.value = [];
    paginationInfo.productPageSize = 0;
    paginationInfo.orderDetailPageSize = 0;
    paginationInfo.totalPageSize = 1;
    paginationInfo.updateCount = 0;
    checkFormInfo.value = {};
};
```


### 完整代码
```ts
import { message, Modal } from 'ant-design-vue';
import { reactive, ref } from 'vue';
import { useRouter } from 'vue-router';
import { generateCheckForm, updateOrderCompelete } from '../api';
import { ORDERSTATUS } from '../order-list/type';
// import { resData } from './component/product-info-data';
const router = useRouter();
// 保存页面信息
export const paginationInfo = reactive({
    productPageSize: 0,
    summationPageSize: 1, // 订单合计页面默认单独一页
    orderDetailPageSize: 0,
    totalPageSize: 0,
    updateCount: 0,
});

// 处理分页数据
export const usePaginationInfo = () => {
    type PageSizeKey = keyof typeof paginationInfo;
    let timer: any = null;

    const updateTotalSize = () => {
        const keys: PageSizeKey[] = ['productPageSize', 'summationPageSize', 'orderDetailPageSize'];
        let totalPageSize = 0;
        keys.forEach((key) => {
            totalPageSize += paginationInfo[key];
        });

        paginationInfo.totalPageSize = totalPageSize;
    };
    // 获取当前模块从第几页开始渲染
    const getPageSizeStartIndex = (pageKey: PageSizeKey) => {
        let startIndex = 0;
        const keys: PageSizeKey[] = ['productPageSize', 'summationPageSize', 'orderDetailPageSize'];
        const keyIndex = keys.indexOf(pageKey);

        keys.slice(0, keyIndex).forEach((key) => {
            startIndex += paginationInfo[key];
        });

        return startIndex;
    };
    /**
     * 更新某个单独的key
     * @param key 页面属性key
     * @param size 页数
     */
    const updatePageSize = (key: PageSizeKey, size: number) => {
        clearTimeout(timer);
        paginationInfo[key] = size;
        paginationInfo.updateCount += 1;

        timer = setTimeout(updateTotalSize, 100);
    };
    return {
        paginationInfo,
        updatePageSize,
        getPageSizeStartIndex,
    };
};
export interface CheckFormProductItem {
    discountAmount: number;
    discountPrice: number;
    freeGiftQuantity: number;
    img: string;
    name: string;
    paidAmount: number;
    price: number;
    quantity: number;
    requireService: number;
    retailPrice: number;
    returnAmount: number;
    returnQuantity: number;
    salesAmount: number;
    salesPrice: number;
    serviceFee: number;
    skuId: number;
    sn: string;
    specification: string;
    unit: string;
}

type PageProductList = CheckFormProductItem[];
// 产品分页
const pageList = ref<PageProductList[]>([]);

// 保存页面列表
const produdtPageNum = ref<number>(0);
export const useCalcProductPages = () => {
    let maxLen = 14; // 每页最多可显示商品数量
    const firstMaxLen = 10;
    const otherMathLen = 14;
    const initPageList = (products: CheckFormProductItem[]): PageProductList[] => {
        const list: PageProductList[] = [];
        const firstPage = products.slice(0, firstMaxLen);
        const otherProducts = products.slice(firstMaxLen);
        const loopCunt = Math.ceil(otherProducts.length / otherMathLen);
        for (let i = 0; i < loopCunt; i += 1) {
            list.push(otherProducts.slice(i * otherMathLen, (i + 1) * otherMathLen));
        }

        list.unshift(firstPage);
        return list;
    };
    // 更新页数
    const { updatePageSize } = usePaginationInfo();

    // 计算产品需要多少页可以
    const calcProductPages = (products: CheckFormProductItem[]) => {
        let list: PageProductList[] = [];
        console.time('calcProductList');
        if (!Array.isArray(products)) {
            return list;
        }
        // 首页11条数据
        if (products.length <= 11) {
            // 只有一页
            list.push(products);
        } else {
            // 多页处理
            list = initPageList(products);
        }
        pageList.value = list;
        produdtPageNum.value = list.length;
        updatePageSize('productPageSize', list.length);
        console.log('productPageSize', list.length);
        return list;
    };

    // 计算产品table 下边距
    const calcProductTableMarginBottom = (prdocutLen: number, pageIndex: number): number => {
        let defaultMarginBottom: number = 40;

        const lineHeight = 44;
        if (pageIndex === 0) {
            // 首页特殊处理
            maxLen = 10;
        } else {
            maxLen = 14;
        }
        // 处理margin bottom
        if (prdocutLen < maxLen) {
            defaultMarginBottom += (maxLen - prdocutLen) * lineHeight;
        }
        defaultMarginBottom -= 1;
        return defaultMarginBottom;
    };

    return {
        pageList,
        produdtPageNum,
        calcProductPages,
        calcProductTableMarginBottom,
    };
};
export interface CheckFormOrderInfo {
    adjustAmount: number;
    amount: number;
    area: string;
    createTime: string;
    createUser: string;
    discountAmount: number;
    houseId: string;
    id: number;
    itemList: CheckFormProductItem[];
    linkman: string;
    orderId: string;
    paidAmount: string;
    phone: string;
    productFeeVersion: number;
    productTypeName: string;
    refundAmount: number;
    solutionVersion: string;
    status: number;
    projectStatus: number;
    storeId: string;
    type: number;
    version: number;
    address: string;
    principal: string;
    principalPhone: string;
    [key: string]: any;
}
export interface CheckFormInfo extends CheckFormOrderInfo {
    subOrders: CheckFormOrderInfo[];
}

// 费用配置
export interface CostConfigItem {
    allowDiscount: number;
    code: string;
    id: number;
    lowestDiscount: number;
    name: string;
    required: number; // 是否必收
    type: number;
    typeName: string;
    value: number;
    version: number;
}
export interface OrderFeeDetailInfo {
    type: string;
    orderId: string;
    extendFeeList: CostConfigItem[];
    showFooter: boolean;
    currentPage?: number;
    marginBottom?: any;
    pageIndex: number;
    isLastFeeDetail: boolean;
}
// 资金明细分页数据
export const orderInvoiceFeePageList = ref<OrderFeeDetailInfo[][]>([]);
// 处理分页
const formatFeeListPagination = <T>(feeList: T): T => {
    const pageMaxLen = 21; // // 页面最大行数包含标题；
    const lineHeight = 32; // 行高
    const maxHeight = pageMaxLen * lineHeight; // 页面最大行数包含标题  => 行高
    let startIdx: number = 0;
    let stepIdx: number = 0;
    const list = ((feeList as unknown) as { value: OrderFeeDetailInfo[] }).value;

    // 更新index
    const updateIdx = (idx: number): void => {
        startIdx = idx;
        stepIdx = 0;
    };
    // 获取有多少行，判断是否能占满一页
    const getLine = (lineList: OrderFeeDetailInfo[]) => {
        const len = lineList.reduce((prev: number, next: OrderFeeDetailInfo): number => {
            prev += next.extendFeeList.length;
            return prev;
        }, 0);

        return len;
    };
    // 计算margin bottom
    const getFeeDetailMarginBottom = (
        lineLen: number,
        detailLen: number,
        info: OrderFeeDetailInfo
    ): number => {
        const initMarginBottom: number = 16; // 默认下边距为16

        // (len - 1) * initMarginBottom 两个订单明细之间会有16像素的级间距
        const currentHeight =
            (lineLen + detailLen) * lineHeight + (detailLen - 1) * initMarginBottom;

        const currentMarginBottom = maxHeight - currentHeight + 25;
        // 没有下边距 需要做分页
        info.marginBottom = {
            marginBottom: `${currentMarginBottom}px`,
        };

        return currentMarginBottom;
    };
    // 对上一组数据强制分页
    const forcePreDetail = (infos: any) => {
        const newInfos = infos.slice(0, -1);
        const len = getLine(newInfos);
        const newPageInfo = newInfos[newInfos.length - 1];
        newPageInfo.showFooter = true;
        getFeeDetailMarginBottom(len, newInfos.length, newPageInfo);
    };

    const multipleDetailFormat = (lineLen: number, infos: OrderFeeDetailInfo[]) => {
        // 满足最大行数 或者 已经遍历所有 就进行处理
        if (lineLen + infos.length >= pageMaxLen || list.length === startIdx + stepIdx) {
            infos[infos.length - 1].showFooter = true;
            // 维护坐标
            updateIdx(startIdx + stepIdx);

            const resutlt = getFeeDetailMarginBottom(
                lineLen,
                infos.length,
                infos[infos.length - 1]
            );
            // 处理上一个
            if (resutlt <= 20) {
                infos[infos.length - 1].showFooter = false;
                infos[infos.length - 1].marginBottom = {};
                // 维护坐标
                updateIdx(startIdx - 1);
                forcePreDetail(infos);
            } else {
                updateIdx(startIdx + stepIdx);
            }
        }
    };
    // 计算页面
    const calcFeeListPage = () => {
        stepIdx += 1;
        const infos = list.slice(startIdx, startIdx + stepIdx);
        const lineLen = getLine(infos);

        // 单条数据判断出数据
        if (list.length === 1) {
            // 页面最多展示15行
            infos[0].showFooter = true;
            getFeeDetailMarginBottom(lineLen, infos.length, infos[0]);
            // 维护坐标
            startIdx = list.length;
            stepIdx = 0;
        } else {
            // 多行的处理
            multipleDetailFormat(lineLen, infos);
        }

        // 递归 直至处理完所有数据
        if (startIdx + stepIdx < list.length) {
            calcFeeListPage();
        }
    };

    // 首次开始计算
    calcFeeListPage();
    let feePageList: any = [[]];
    let pageIndex = 0;
    list.forEach((item) => {
        feePageList[feePageList.length - 1].push(item);
        // 处理页面下标 分页
        if (item.showFooter) {
            feePageList.push([]);
            item.pageIndex = pageIndex;
            pageIndex += 1;
        }
    });
    // 去除空数组
    feePageList = feePageList.filter((arr: any[]) => arr.length);
    orderInvoiceFeePageList.value = feePageList;
    // 更新页数
    const { updatePageSize } = usePaginationInfo();

    updatePageSize('orderDetailPageSize', feePageList.length);
    console.log('orderDetailPageSize', feePageList.length);
    return feeList;
};
// 结算单价格明细
export const orderInvoiceFeeList = ref<OrderFeeDetailInfo[]>([]);
// 处理价格明细
const formatFeeList = (info: CheckFormOrderInfo): void => {
    orderInvoiceFeeList.value = [
        {
            type: 'orginOrder',
            orderId: info.orderId,
            extendFeeList: info.extendFeeList,
            showFooter: false,
            marginBottom: {},
            pageIndex: 0,
            isLastFeeDetail: false,
        },
    ];
    // 处理子单
    if (Array.isArray(info.subOrders)) {
        info.subOrders.forEach((subInfo) => {
            orderInvoiceFeeList.value.push({
                type: 'childOrder',
                orderId: subInfo.orderId,
                extendFeeList: subInfo.extendFeeList || [],
                showFooter: false,
                marginBottom: {},
                pageIndex: 0,
                isLastFeeDetail: false,
            });
        });
    }
    formatFeeListPagination<{ value: OrderFeeDetailInfo[] }>(orderInvoiceFeeList);
};

const { calcProductPages } = useCalcProductPages();
// 结算单信息
const checkFormInfo = ref<CheckFormInfo | { [key: string]: any }>({});
// 清除页面数据
const clearPageInfo = () => {
    pageList.value = [];
    orderInvoiceFeePageList.value = [];
    paginationInfo.productPageSize = 0;
    paginationInfo.orderDetailPageSize = 0;
    paginationInfo.totalPageSize = 1;
    paginationInfo.updateCount = 0;
    checkFormInfo.value = {};
};

```


### 总结
> 1. 打印的宽度是A4纸横版打印，所以宽度是A4纸的高，长度是A4纸的宽度
> 2. 在实际调试的时候 会发现 当我们使用了 transform 对字体进行缩放，会出现一个大的空白，这个时候 我们对显示的内容给一个包裹层，然对该包裹成进行1.24的放大，
>   位移，可以保证原先的两边间隔
> 3. 页面宽度是固定的，所以需要对显示内容进行特定的处理，防止溢出
> 4. 也是在我们使用缩放，以及位移后，页面显示会和生成PDF有偏差，调整的时候，一定要以PDF预览为准
> 5. 页面有可能因为margin等导致生成PDF后多出一个空白页，这个时候 我们可以将页面的边框给个颜色，对着将边距等调好即可
> 6. 当我们页面数据不足撑满当前页面时，我们设置margin元素可能会出现失效的问题，这个时候 我们可以使用一个空标签，(ProductInfoRender.vue 文件中 有一个empty-box)来让margin生效
> 7. 最后就是生成PDF时，有图片和没有图片性能差距很大。这个需要视情况而定，(我测试，560各产品，有产品图片和没有产品图片的预览速度是3倍)
> 8. 设置背景会发现不生效，这时候 我们要给一个空元素设置边框宽度和颜色，然后定位，调整层级关系，并将需要展示背景的元素背景颜色设置为transparent，才能保证页面展示背景
> 9. 定位的时候可能出现位置偏移，最后在需要背景的元素外边嵌套一个相对定位的元素，用来确保位置不会偏差
> 10. 到此位置，已经完成像素级别的可分页打印(为了方便计算。可以偷懒将行高固定，这样可以优化计算过程)