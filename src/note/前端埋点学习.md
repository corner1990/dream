# 前端埋点学习

- 埋点：是网站分析的一种常用的数据采集方式。我们主要采集用户的行为数据(例如页面访问路径，点击了什么元素)，进行数据分析，从而让运营同学更加合理的安排运营计划。

- 为什么要埋点：现在的互联网公司越来越关注转化，新增，留存，而不是简单的PV, UV。完整的采集数据是一切的前提

- 埋点主要包括：IOS，Android，H5，小程序等前端埋点，还有后端业务埋点。

- PV(访问量)：即Pages View，页面浏览量或者点击量，用户每次刷新即被计算一次

- UV(独立访客)：即Unique Visitor，访问您网站的一台电脑客户端为一个访客，00:00-24:00PM客户端只被记一次。

  > PS：一个UV可以用很多PV，一个PV也只能对应一个IP

### 前端埋点和后端埋点不同点

- 数据收集

  + 前端埋点：收集数据在客户端进行，意味着可以手机更多的browser端的数据，例如用户事件行为，界面变化，页面停留时长.....
  + 后端埋点：收集数据在服务端进行，意味着收集的是http request发生时的数据，获取到更多的是数据层，业务逻辑层。如数据交互…部分情况下如需要考虑技术架构，如前端mv* + 后端RESTful API；前端HTML模板+后端MVC，两种架构在前后端能够获取的数据差异也很大

- 反作弊

  > spam: 发送垃圾技术，常用的技术在有隐藏文本，重复关键字，使用无关关键字，过度提交，连接搜索引擎垃圾技术，类似于SEO的非正常技术手段称为SPAM

  + 两种数据收集都会发生SPAM，前端所有页面上的数据都可以被更改，并且，可以直接调用数据阐述接口来产生假数据
  + 后端埋点产生SPAM,则需要实实在在的发生请求到服务器

- 爬虫数据

  + web的前端埋点基本使用js，目前爬虫虽然可以能模拟用户真是请求，执行js，但是大部分爬虫并不执行js，因为前端埋点不一定包含爬虫产生数据
  + 后端埋点一定包含爬虫产生数据

- 数据暂存与性能开销

  > 通常，数据收集之后并非立即发送到数据服务器，而是回暂存起来，并在请求页面，或者一段时间后，或者网络状态良好的时候一起发送到数据服务器

  + 前端埋点数据发送到数据服务器之前，都是存在用户的设备端，比如cookie，localStorage里，运行数据手机的程序性能开销，都由用户设备承担
  + 后端埋点的时候，数据保存，收集数据运行的程序开销都是服务器，因此相对前度埋点，后端埋点更注重性能

- 用户识别访问

  + 前端埋点，web主要使用cookie/localstorage里存放用户信息，App使用设备标识符来识别是是否同一个用户，但是cookie和设别标识符可能被清空/修改/重置，则使用多个设备的同一个用户无法被关联，尤其是在web端存在跨域的问题，跨域资源共享的cookie操作非常麻烦，识别同一用户准确度较低
  + 后端埋点，识别跨域服务器的同次访问可共享session，使用同一个用户可以使用IP地址+UA(user agent)拼成的fingerprint(这种方法不能跨设备),用户登录后使用用户ID进行关联(此方法可跨设备，且用户准确度较高)

### 前端埋点的实现手段

- 手工埋点

  > 手动代码埋点比较常见，需要调用埋点的业务方在需要采集数据的地方调用埋点的方法。

  + 优点：流量可控，业务方可以根据需要在任意地点任意场景进行数据采集，采集信息也完全又也无妨来控制
  + 缺点：需要也无妨来写死方法，如果采集方案变了，也无妨也需要重新修改代码，重新发布

- 可视化埋点

  > 可视化埋点是近几年的埋点趋势，很多大厂自己的数据埋点部门也都开始做这些。

  + 优点：业务方工作量小
  + 缺点：技术上推广和实现有些困难(业务方前端代码规范是一个大前提)。例如阿里的活动也很多都是运营通过可视化的页面拖拽配置实现，这些活动元素都带有唯一标识。通过埋点配置后台，将元素与要采集的时间关联起来，可以自动生成埋点代码嵌入到页面中

- 无埋点

  > 无埋点则是前端自动采集全部事件，上报埋点数据，由后台来过滤和计算出有用的数据

  + 优点：前端只需要在加载埋点脚本。
  + 缺点：流量和采集的数据过于庞大，服务器性能压力超级巨大，主流的[GrowingIO](https://baike.baidu.com/item/GrowingIO/19490947?fr=aladdin) 就是这种方法

### 手动埋点（代码埋点）

- 纯手动写代码，调用埋点的SDK的函数，在需要埋点的业务逻辑功能为止调用接口上报埋点数据，友盟，百度统计等等第三方数据统计大厂都用这种解决方法

- 手动埋点可以让使用者方便的设置自定义属性，自定义事件。在需要深入下潜，并精细化自定义分析时，比较适合使用手动埋点

- 手动埋点可以获取的数据

  - 域名：document.domainURLdocument.URL
  - 页面标题：document.title
  - 分辨率：window.screen.height & window.screen.width
  - 颜色深度：window.screen.colorDepth
  - Referrer：document.referrer
  - 客户端语言：navigator.language

- 除了上边的常规信息，自己相关的业务数据，都需要我们通过手动编写js来实现

- 手动埋点的几种方式

  - 命令式

    - `$(document).ready(()=>{ // ... 这里是你的业务逻辑代码 sendData(params); //这里是发送你的埋点数据，params是你封装的埋点数据 }); // 按钮点击时发送埋点请求 `
    - `$('button').click(()=>{ // ... 业务逻辑 sendData(params); //同上 });`
    - 这里的sendData有很多种方式，比如基于ajax发送json数据，或者使用URL连接带上params，或者使用一像素图片带上数据，或者使用head带上埋点数据，封装方式有多种多样。

  - 命令式

    - `<button data-mydata="{key:'uber_comt_share_ck', act: 'click',msg:{}}">打车</button>` , 这里申明了自定义属性`data-mydata`, 我们可以在SDK中去扫描和识别这些自定义属性，并解析封装数据，在SDK中按自定义规则去绑定事件并发送埋点数据

  - 前端框架式

    > 如果使用Vue或者React等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点的次数，可以在各个生命周期的位置，根据自己的需求封装需要的埋点。

  - CSS埋点

    - `.link:active::after{ content: url("http://www.example.com?action=yourdata"); } <a class="link">点击我，会发埋点数据</a>`, 
    - 这里使用了css的某写特征，这些可以出发发送请求的特征

### 可视化埋点(框架式埋点， 无痕埋点)

- 结局了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集借点(圈点)，前端自动解析配置，并根据配置伤处埋点数据，比起手动埋点看起来更无痕，这里的配置数据可以设置过滤条件，避免针对所有元素，可以在调用开启自动监控API时通过设置一些特征属性，来过滤不符合条件的元素，实现只针对某些元素进行自动上报数据的需求。
- 比如国外比较早做可视化的是Mixpanel，国内较早支持可视化埋点的有 [TalkingData](https://baike.baidu.com/item/TalkingData)、[诸葛IO](https://baike.baidu.com/item/%E8%AF%B8%E8%91%9BIO)，2017年腾讯的 [MTA](http://wiki.open.qq.com/wiki/mobile/MTA%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%85%A5%E6%8C%87%E5%BC%95) 也宣布支持可视化埋点；相比于手动埋点更新困难，埋点成本高的问题，可视化埋点优化了移动运营中数据采集的流程，能够支持产品运营随时调整埋点，无需再走发版流程，直接把配置结果推入到前端，数据采集流程更简化，也更方便产品的迭代。
- 可视化埋点中多数基于Xpath (右键审查元素-> element面板 -> 选择dom元素 -> copy -> copy XPath)  的方案，XPath 是一门在 XML 文档中查找信息的语言。XPath可用来在 XML 文档中对元素和属性进行遍历。
- 比如标识的位置，其中的xpath是：//*[@id="projects"]/a[4](https://img.mukewang.com/5adb5d920001e8da10801225.png)/img，如果换成DOM的selector：#projects > a:nth-child(4) > img。通过这些信息可以精准定位到一个DOM节点，xpath方案分为精确路径和概略路径两种做法，精确路径从被点击的元素不断向上冒泡查找到根节点，并记录过程中每个节点的。如果用户阻止了冒泡会导致失效，概略路径是在前者的基础仅仅向上查找白名单中的节点。但是如果DOM节点有任何变化，对应的xpath数组就是被打乱，很容易影响采集。
- 可视化埋点配置化能力相对手动埋点更强，是对手动埋点的补充，而不是替代，很多手动埋点都可以通过好的规划和架构变味可视化埋点

### 无埋点（自动埋点、全埋点）

- 无埋点并不是没有任何埋点，所谓的无只是不需要工程师在业务代码李插入侵入式的代码，只需要简单的夹在一段定义好的SDK代码，技术门槛更低，使用与部署也简单，比敏啊了需求变更，埋点错误导致的重新埋点
- 通过SDK代码，前端回自动全量采集全部事件并上报埋点数据。能够呈现用户行为的每一次点击，跳转，登录等全量，实时的用户行为数据，这些数据传到后端后，可以通过用户分群，漏斗对比等功能，分析不同的访问来源，城市，不同的逛啊噢来源等多维度的不同转化细节，细而全。
- 无埋点相比可视化埋点，在解决数据“回溯”问题上更有优势，如果你想分析某一天某个控件的点击情况，如果你没有针对这个按钮做可视化埋点，则只能从你针对这个按钮做可视化配置的这一时刻之后才有埋点数据，而无埋点，则从你部署SDK那一刻就一直有数据在收集；无埋点做热力图也更有优势，无埋点可以告诉使用者这个界面上每个控件分别被点击的概率是多大，通过热力图清晰可见。无埋点的劣势是自定义属性不灵活，传输时效性差，数据可靠性欠佳，耗费网络流量，还会增加服务器负载，而且兼容性也不佳。
- 神策： 根据官方的介绍，设置AutoTrack之后，SDK就会自动解析HTML页面上的( a 、 button 、 input )标签。 并记录这些标签的点击情况，一旦页面某一个按钮发生了点击行为，SDK就会去采集此按钮的一些信息，例如: 这个按钮的标签类型，这个按钮的文本内容，这个按钮的 name ，这个按钮的 id 、 class 名，还有一些按钮特有的属性如 href等。
- Mixpanel： 设置AutoTrack之后，SDK会监测页面上的所有 form表单 、 input标签 、 select和textarea标签 产生的 submit 、 change 、 click 事件，并采集这些标签上的属性一起上报。
- 无埋点确实发送的埋点数量很巨大，比如知乎上就有很多人质疑无埋点解决方案。很多用户对无埋点发送大量埋点请求表示不理解，但是由于无埋点技术方案的限制，无埋点的可交互元素众多，每一次交互都会发送请求，所以会导致网络请求过重。神策等官方文档中也建议无埋点最好使用在那些按钮不是很多的，相对简单的页面。

### 埋点需求整理原则

原则是基于一系列问题展开的，并基于这些问题确定埋点要求。

- 时间纬度：埋点可用的周期，会持续多久
- 埋点广度：先有的埋点有哪些可以满足我们的埋点需求，需要新的埋点有多少，这些埋点是否最必要。
- 效果统计：怎么验证效果，需要那些埋点，前端这里应该怎么埋点，数据结果怎么看
- 埋点场景：工呢个实在用户场景什么时候调用产生？调用的过程中会有什么交互？功能调用正常情况下大概需要多长时间？什么情况下回影响调用结果？调用有风险的时候，是否需要加检测
- 埋点落地：用户特征是什么？对部分特征用户预期的的数据结果是什么？用户习惯是什么？

### 埋点规范

- 在埋点过程中常见的问题

  + 常常埋错，漏埋
  + 业务变化后，老埋点数据失去意义
  + 埋点数据无人使用，浪费资源
  + 数据团队，研发团队，产品团队协作配合难度大
  + 无用/重复埋点太多，干扰正常埋点数据
  + 大量存量埋点Owner离职或者转岗，导致大量僵尸埋点信息

- 埋点规范

  + 规范内容：
    + 需求阶段：确定埋点信息，核心包括五个方面信息：事件ID，埋点名称，埋点描述，埋点属性以及截图
    + 开发阶段：和产品，需求人员沟通，做到理解业务语义的情况下，在前端按照埋点的代码规范进行埋点
    + 验收阶段：和相关人员在完全理解业务语义的情况下，可以通过与自比较和他比较的方式来进行验证。自我验证：同一个网站，某一个业务线的注册数量一定要小于所有业务线的总和。他比较验证：前端业务点数量和对应的服务端数据应该基本相当。
    + 清理阶段：确认完全理解语义的情况下，可对业务发生巨大变化或者不在维护的埋点进行废弃

  + 第一种做法：名称只能又字母、数字、下划线组成，并保证应用内唯一，比如sw是展示，ck是点击
    - 常用的举例如下
    - 行为埋点：{团队|业务|角色} _ {组件|页面} _ {具体元素} _ {动作}
    - yourteam_fc_all_msg_ck 
    - autoplatform_flowtab_sw ： autoplatform代表业务线，flowtab 代表功能，sw代表页面操作，sw是展示，ck是点击 
    - user_comt_share_ck ：user业务线，comt评价组件，share分享按钮，ck点击

- 埋点需要注意的问题

  + 如果是普通的http协议，在数据传输的过程存在被劫持(包括不限于js代码注入等)的可能性，早正H5或者web页面出现诸如未知的广告或者原网页被重定向等问题。为了降低此类事件的发生的可能性，建议最好使用https协议，以确保数据传输过程的完整性，安全性。
  + 版本迭代的时候埋点需要注意的问题
    - 公用模块，可以放心安全的全量迁移埋点
    - 新增模块：需要注意是否遵循了最新的埋点规范，有没有重复的埋点命名存在，埋点是否否呵业务逻辑
    - 下线模块：苹果下线后对数据的影响范围，而且要第一时间充分周知相关方，让各方参与评估
    - 更新模块：需要评估在原有埋点上需要修改的埋点内容，是否需要重新埋点，删除不需要的埋点，而且要修改功能的数据承接

- 埋点上报的解决方案

  + 一般回实现几个模块，Event收集器，Event缓存器和Event上报器
  + Event上报模式：除了用户个人不希望耗费流量以外，也可能回因为弱网及断网的情况，如果确保数据不丢失，基于这些问题而诞生的上传策略，来设计如何上报已经好搜几的所有时间数据。上报一般包括正对内存实时数据的上报和本地持久化数据上报两个部分，一下是他们的上报策略和实现方式
  + 内存埋点数据实时上报
    + 基于时间间隔：每个n秒(时间间隔需要根据公司业务视情况而定)
    + 几句数据条数：每累计n条数据（条数可以自定义）
    + 不间断实时上报，如果是低频率，数据量小，实时性要求高的数据可以不设限制
  + 本地迟就画数据的延迟上报
    + 为了尽早的上传持久化埋点数据，以防用户关闭浏览器或者卸载浏览器造成本地数据丢失，针对本地持久化数据的上传策略如下：
    + HTML5、Hybrid相关：
      + localstorage，浏览器关闭埋点数据并不会被删除，如果用户再次访问就会启动上报
      + 可以创建一个单独的串行队列，来实现都会本地持久化数据的逐个上报