# 设计原则

### 什么是设计
- 按照哪一种思路或者标准实现功能
- 功能相同，可以有不同的设计方式
- 如果需求不断变化，设计的作用才能体现出来

### SOLID五大设计原则

| 首字母 | 指代         | 概念                                                         |
| :----- | :----------- | :----------------------------------------------------------- |
| S      | 单一职责原则 | 单一功能原则认为对象应该仅具有一种单一功能的概念。           |
| O      | 开放封闭原则 | 开闭原则认为“软件体应该是对于扩展开放的，但是对于修改封闭的”的概念。 |
| L      | 里氏替换原则 | 里氏替换原则认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考 契约式设计。 |
| I      | 接口隔离原则 | 接口隔离原则认为“多个特定客户端接口要好于一个宽泛用途的接口”[5] 的概念。 |
| D      | 依赖反转原则 | 依赖反转原则认为一个方法应该遵从“依赖于抽象而不是一个实例”[5] 的概念。依赖注入是该原则的一种实现方式。 |

### 单一原则

- 一个程序只做一件事
- 如果功能很复杂就进行拆分

### 开放封闭原则

- 对扩展开放，对修改关闭
- 增加需求时，扩展新代码，而非修改已有代码
- 这是软件设计的化境

```js
// 拆分功能
function parseJSON(response) {
  return response.json();
}

function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  }

  const error = new Error(response.statusText);
  error.response = response;
  throw error;
}

//  使用
export default function request(url, options) {
  return fetch(url, options)
    .then(checkStatus)
    .then(parseJSON)
    .then(data=>{data})
    .catch(err => ({ err }));
}
```
### L 理氏替换原则
- 子类能够覆盖父类，
- 父类出现的地方子类就能出现
- JS使用的比较少

```ts
class Person {

  buy () {
    console.log('买东西')
  }
}

class Man extends Person {
  constructor(gender, name) {
    super()
    this.gender = gender
    this.name = name
  }
  buy () {
    console.log('买游戏机')
  }
}

class Women extends Person {
  constructor(gender, name) {
    super()
    this.gender = gender
    this.name = name
  }
  buy () {
    console.log('买包包')
  }
}

let p = new Person()
let m = new Man('男人')
let w = new Women('女人')
// 子类可以覆盖父类
p.buy()
m.buy()
w.buy()

let leo = {
  marry (p:Penson) {
    console.log(`leo 和 ${p.name} 结婚了！`)
  }
}

leo.marry(new Women('女'，'如花'))
leo.marry(new Man('男'，'武大郎'))
```
### 接口隔离原则
- 保持接口的单一独立，避免出现胖接口
- JS中没有接口，所以只有在typescipt中时会有体现
```ts
// 不同的功能使用定义不同的接口
interface Person {
  fristName: string,
  lastName: string
}

interface Fly{
  fly: boolean
}

function greeting (obj:Person) {
  console.log(`${obj.fristName}${obj.lastName} say hello`)
}

let p = {fristName: 'zhang', lastName: 'san'}
greeting(p)
```

### 依赖倒置原则
- 面向接口编程，依赖抽象，而不依赖实现
- 使用方只关注接口而不关注具体类的实现
- JS中使用较少（没有接口，弱类型）

